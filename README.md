# SmithMaskingStudy

<div style="border: 1px solid grey; width: 70%; min-width: 300px; padding: 10px; border-radius: 5px; margin: auto;">
Work in progress
<hr>
Things to do/finish:
<ul>
    <li>Error prediction</li>
    <li>Python scripts</li>
    <li>Masking correction</li>
    <li>Readme (installation, dependencies, database, links, etc.)</li>
    <li>Cleaning code
        <ul>
            <li>Respect outLevel in console</li>
            <li>Check manually closed files<li>
        </ul>
    </li>
</ul>
</div>

## Notes

This is a C++ code I wrote during my PhD. I am currently cleaning it up in order to provide public and easy access to it, and reproduce results of my research.

The code has several features but is mainly developed in order to analyze the theoretical masking term from Smith (1967) and Ashikhmin et al. (2000) when applied to real-life microsurfaces. It can predict the error and correct the masking from the mesh and without ray casting.

For a full reproduction of the methodology, python scripts should be run on outputs generated by the C++ code.
PhD project.

## Run

The program reads parameters from a JSON file.
```console
$ SmithMaskingStudy parameters.json
```

To show a short example of a JSON file, run
```console
$ SmithMaskingStudy -e
```

## Parameters (JSON file)

### Overview

The input JSON file contains all parameters which can be used when running SmithMaskingStudy. Most of them have default values, but some are required.

The JSON file must follow the excerpt given below. `userParams` is an array that can contains several parameters set, which can be useful if you want to run different methods in one input.

```json
{
    "userParams":[
        {
            "methodParams": {...},
            "pathParams": {...},
            "directionParams": {...},
            "ndfParams": {...},
            "sideEffectParams": {...},
            "renderingParams": {...},
            "outLevel": ...,
            "log": ...,
        }
    ]
}
```

### Method

> Required.

```json
"methodParams": {
    "name": "G1" | "GAF" | "D_TABULATION" | "FEATURES" | "FULL_PIPELINE" | "AMBIENT_OCCLUSION" | "GENERATE_MICROFLAKES",
    "computeError": bool,
    "jiggleFlakes": bool
}
```
- `name` (**required**). Must be one of the followings:
    - **G1**: measure ground-truth masking $G_1^{rc}$ with ray casting, compute theoretical masking $G_1$. Results are saved as 2D tabulations .csv files and functions are plotted in .png files.
    - **GAF**: same as G1 method, but for full visibility (masking and shadowing). The theoretical is computed with decorrelated $G_1(i)G_1(o)$. 
    - **D_TABULATION**: tabulate the 2D normal distribution function $D$.
    - **AMBIENT_OCCLUSION**: create the ambient occlusion map from the mesh.
    - **FEATURES**: extract features from the mesh, needed to predict the error, and save them in a features.csv file. If `.computeError` is set to `true`, SMAPE error $E$ between $G_1^{rc}$ and $G_1$ is also computed and added to the file.
    - **GENERATE_MICROFLAKES**: generate a microflakes mesh from a heightfield. Normals are first computed, then triangle faces are added without connecting to other faces. If `methodParams.jiggleFlakes` is set to `true`, flakes heights are randomized, changing heights distribution but keeping normals distribution the same.
    - **FULL_PIPELINE**: the full pipeline to predict masking error: tabulate $D$, $G_1^{rc}$ and $G_1$, compute the error $E$, and extract mesh features.
- `computeError` (default `false`). Only works if `methodParams.name == "FEATURES"`. If set to `true`, ray casting is used to compute error~$E$.
- `jiggleFlakes` (default `false`). Only works if `methodParams.name == "GENERATE_MICROFLAKES"`. If set to `true`, heights of generated flakes are randomized.

### Paths

> Required.

```json
"pathParams": {
    "objDir": string,
    "hfDir": string,
    "outputsDir": string,
    "surfNames": array<string>,
    "surfMin": int (in [1, 334]),
    "surfMax": int (in [1, 334]),
    "resolutions": array<int>,
    "gnuplotPath": string,
    "ptxFile": string
}
```

- `objDir` (**required**). Root directory where mesh .obj files are stored.
- `hfDir` (**required** if `methodParams.name` is `"GENERATE_MICROFLAKES"`). Root directory where heightfields .png files are stored.
- `outputsDir` (**required**). Root directory for all generated output files.
- `surfNames` (**required** if `surfMin` or `surfMax` are null). List of surfaces names, no extension (might include subpath).
- `surfMin` (**required** if surfNames is null). For PerTex database, gives the minimum index to start iteration. `surfMax` must also be set (`surfMin` $\leq$ `surfMax`).
- `surfMax` (**required** if surfNames is null). For PerTex database, gives the maximum index to start iteration. `surfMin` must also be set (`surfMin` $\leq$ `surfMax`).
- `resolutions` (default `[8]`). List of meshes resolutions (number of subdivisions), with obj files stored in directory `<objFolder>/<resolution>_subdivisions/`.
- `gnuplotPath` (default `"gnuplot"`). path/to/gnuplot.exe, needed to save graphs.
- `ptxFile` (default `"./sources/cuda/devicePrograms.cu.ptx"`). Path to the ptxFile generated from the cuda file. Needed to measure masking with ray tracing.


The input folder must respect the following tree structure:
```
<objDir>
├───<k>_subdivisions/
│   └───PerTex/
│   │   ├─── 001.obj
│   │   ├─── 002.obj
│   │   ├─── ...
│   │   └─── 334.obj
│   └───path/to/meshes/*.obj
└───<k>_subdivisions/

<hfDir>
└───PerTex/
│   ├─── 001.png
│   ├─── 002.png
│   ├─── ...
│   └─── 334.png
└───path/to/heightfields/*.png
```

### Directions

> Optional.

```json
"directionParams": {
    "phiStart": float in [-pi, +pi],
    "phiEnd": float in [-pi, +pi],
    "nPhiSamples": int > 0,
    "thetaStart": float in [-pi/2, pi/2],
    "thetaEnd": float in [-pi/2, pi/2],
    "nThetaSamples": int > 0
}
```

- `phiStart` (default `-pi`): minimal $\phi_o$
- `phiEnd` (default `+pi`): maximal $\phi_o$
- `nPhiSamples` (default `1`): number of $\phi_o$ sampled
- `thetaStart` (default `0`): minimal $\theta_o$
- `thetaEnd` (default `pi/2`): maximal $\theta_o$
- `nThetaSamples` (default `90`): number of $\theta_o$ sampled

`"directionParams"` can also be `"directionInParams"` or `"directionOutParams"` to specify direction parameters for $i$ (In) and $o$ (Out), useful for GAF computation.

### NDF

> Optional.

```json
"ndfParams": {
    "nTheta": int,
    "nPhi": int
}
```

- `nPhi` (default `400`): number of $\phi_m$ values for $D$ tabulation
- `nTheta` (default `100`): number of $\theta_m$ values for $D$ tabulation

### Side effects

> Optional.

```json
"sideEffectParams": {
    "borderPercentage": float in [0, 1],
    "BBox": bool
}
```

- `borderPercentage` (default `0.2`). Percentage of the macrosurface which won't be sampled to compute masking, but will be used to intersect rays.
- `BBox` (default `false`). If set to `true`, uses the side faces of the mesh's BBox to block rays.

### Rendering

> Optional. Used only if the selected method measures $G_1^{rc}$ with ray casting.

```json
"renderingParams": {
    "renderSize": int[2],
    "nPixelSamples" int,
    "createPicture": bool,
    "useSmooth": bool
}
```

- `renderSize` (default `[1024, 1024]`). Size in pixels of the OptiX camera to sample macrosurface and measure masking.
- `nPixelSamples` (default `4`). Number of samples (rays) per pixel.
- `createPicture` (default `false`). Render the microsurface as a .png image, seen from top.
- `useSmooth` (default `false`). If set to `true`, compute smooth normals by interpolating between microfacets geometric normals. Note that it will create an inconsistance between $G_1^{rc}$ which can be measured with intersection on non-smooth surface, and $G_1$ which will be derived from a smooth distribution $D$.

### Other parameters

> Optional.

```json
"outLevel": "NO_OUTPUT" | "ERR" | "WARNING" | "INFO" | "TRACE",
"log": bool
```

- `outLevel` (default `"WARNING"`). Must be one of the followings:
  - **NO_OUTPUT**: don't print anything in the console (not recommanded).
  - **ERR**: print only error messages.
  - **WARNING**: print error and warning messages.
  - **INFO**: print error, warning, and info messages.
  - **TRACE**: print error, warning, info messages, and print important methods names when they are runned.
- `log` (default `false`). If set to `true`, different informations will be saved in a .txt file in directory `<outputsDir>/logs/`.
